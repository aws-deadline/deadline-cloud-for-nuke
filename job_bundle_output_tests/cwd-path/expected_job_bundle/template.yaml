specificationVersion: '2022-09-01'
name: cwd-path.nk
parameters:
- name: NukeScriptFile
  type: PATH
  objectType: FILE
  dataFlow: IN
  userInterface:
    control: CHOOSE_INPUT_FILE
    label: Nuke Script File
    fileFilters:
    - label: Nuke Script Files
      patterns:
      - '*.nk'
    - label: All Files
      patterns:
      - '*'
  description: The Nuke script file to render.
- name: Frames
  type: STRING
  description: The frames to render. E.g. 1-3,8,11-15
  minLength: 1
- name: WriteNode
  type: STRING
  userInterface:
    control: DROPDOWN_LIST
    label: Write Node
  description: Which write node to render ('All Write Nodes' for all of them)
  default: All Write Nodes
  allowedValues:
  - All Write Nodes
  - Write1
- name: View
  type: STRING
  userInterface:
    control: DROPDOWN_LIST
  description: Which view to render ('All Views' for all of them)
  default: All Views
  allowedValues:
  - All Views
  - main
- name: ProxyMode
  type: STRING
  userInterface:
    control: CHECK_BOX
    label: Proxy Mode
  description: Render in Proxy Mode.
  default: 'false'
  allowedValues:
  - 'true'
  - 'false'
- name: ContinueOnError
  type: STRING
  userInterface:
    control: CHECK_BOX
    label: Continue On Error
  description: Continue processing when errors occur.
  default: 'false'
  allowedValues:
  - 'true'
  - 'false'
- name: NukeVersion
  type: STRING
  userInterface:
    control: LINE_EDIT
    label: Nuke Version
  description: The version of Nuke.
- name: RezPackages
  type: STRING
  userInterface:
    control: LINE_EDIT
    label: Rez Packages
  description: A space-separated list of Rez packages to install
  default: nuke-13 deadline_cloud_for_nuke
environments:
- name: Rez
  description: Initializes and destroys the Rez environment for the job.
  script:
    actions:
      onEnter:
        command: '{{ Env.File.Enter }}'
      onExit:
        command: '{{ Env.File.Exit }}'
    embeddedFiles:
    - name: Enter
      filename: rez-enter.sh
      type: TEXT
      runnable: true
      data: |
        #!/bin/env bash

        set -euo pipefail

        if [ ! -z "{{Param.RezPackages}}" ]; then
            echo "Rez Package List:"
            echo "   {{Param.RezPackages}}"

            # Create the environment
            /usr/local/bin/deadline-rez init \
                -d "{{Session.WorkingDirectory}}" \
                {{Param.RezPackages}}

            # Capture the environment's vars
            {{Env.File.InitialVars}}
            . /usr/local/bin/deadline-rez activate \
                -d "{{Session.WorkingDirectory}}"
            {{Env.File.CaptureVars}}
        else
            echo "No Rez Packages, skipping environment creation."
        fi
    - name: Exit
      filename: rez-exit.sh
      type: TEXT
      runnable: true
      data: |
        #!/bin/env bash

        set -euo pipefail

        if [ ! -z "{{Param.RezPackages}}" ]; then
            echo "Rez Package List:"
            echo "   {{Param.RezPackages}}"

            /usr/local/bin/deadline-rez destroy \
                -d "{{ Session.WorkingDirectory }}"
        else
            echo "No Rez Packages, skipping environment teardown."
        fi
    - name: InitialVars
      filename: initial-vars.sh
      type: TEXT
      runnable: true
      data: |
        #!/usr/bin/env python3
        import os, json
        envfile = "{{Session.WorkingDirectory}}/.envInitial"
        with open(envfile, "w", encoding="utf8") as f:
            json.dump(dict(os.environ), f)
    - name: CaptureVars
      filename: capture-vars.sh
      type: TEXT
      runnable: true
      data: |
        #!/usr/bin/env python3
        import os, json, sys
        envfile = "{{Session.WorkingDirectory}}/.envInitial"
        if os.path.isfile(envfile):
            with open(envfile, "r", encoding="utf8") as f:
                before = json.load(f)
        else:
            print("No initial environment found, must run Env.File.CaptureVars script first")
            sys.exit(1)
        after = dict(os.environ)

        put = {k: v for k, v in after.items() if v != before.get(k)}
        delete = {k for k in before if k not in after}

        for k, v in put.items():
            print(f"updating {k}={v}")
            print(f"openjobio_env: {k}={v}")
        for k in delete:
            print(f"openjobio_unset_env: {k}")
steps:
- name: Render
  parameterSpace:
    parameters:
    - name: Frame
      type: INT
      range: '{{Param.Frames}}'
  environments:
  - name: Nuke
    description: Runs Nuke in the background with a script file loaded.
    script:
      embeddedFiles:
      - name: initData
        filename: init-data.yaml
        type: TEXT
        data: |
          continue_on_error: {{Param.ContinueOnError}}
          proxy: {{Param.ProxyMode}}
          script_file: '{{Param.NukeScriptFile}}'
          version: '{{Param.NukeVersion}}'
          write_nodes:
          - '{{Param.WriteNode}}'
          views:
          - '{{Param.View}}'
      actions:
        onEnter:
          command: NukeAdaptor
          args:
          - daemon
          - start
          - --path-mapping-rules
          - file://{{Session.PathMappingRulesFile}}
          - --connection-file
          - '{{Session.WorkingDirectory}}/connection.json'
          - --init-data
          - file://{{ Env.File.initData }}
          cancelation:
            mode: NOTIFY_THEN_TERMINATE
        onExit:
          command: NukeAdaptor
          args:
          - daemon
          - stop
          - --connection-file
          - '{{ Session.WorkingDirectory }}/connection.json'
          cancelation:
            mode: NOTIFY_THEN_TERMINATE
  script:
    embeddedFiles:
    - name: runData
      filename: run-data.yaml
      type: TEXT
      data: 'frame: {{Task.Param.Frame}}'
    actions:
      onRun:
        command: NukeAdaptor
        args:
        - daemon
        - run
        - --connection-file
        - '{{Session.WorkingDirectory}}/connection.json'
        - --run-data
        - file://{{ Task.File.runData }}
        cancelation:
          mode: NOTIFY_THEN_TERMINATE
